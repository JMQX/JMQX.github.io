[{"title":"算法学习笔记-DP动态规划","date":"2017-04-23T13:12:39.000Z","path":"2017/04/23/算法学习笔记-DP动态规划/","text":"动态规划 动态规划相信大家都知道，动态规划算法也是新手在刚接触算法设计时很苦恼的问题，有时候觉得难以理解，但是真正理解之后，就会觉得动态规划其实并没有想象中那么难。网上也有很多关于讲解动态规划的文章，大多都是叙述概念，讲解原理，让人觉得晦涩难懂，即使一时间看懂了，发现当自己做题的时候又会觉得无所适从。我觉得，理解算法最重要的还是在于练习，只有通过自己练习，才可以更快地提升。话不多说，接下来，下面我就通过一个例子来一步一步讲解动态规划是怎样使用的，只有知道怎样使用，才能更好地理解，而不是一味地对概念和原理进行反复琢磨。 总结，能用动规解决的问题的特点 问题具有最优子结构性质。如果问题的最优解所包含的 子问题的解也是最优的，我们就称该问题具有最优子结 构性质。 无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。 首先，我们来看一道题:数值三角形 7 3 88 1 02 7 4 44 5 2 6 5 在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99 输入格式： 5 //表示三角形的行数 接下来输入三角形 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 要求输出最大和 代码1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int num[n][n]; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;i+1;j++)&#123; cin&gt;&gt;num[i][j]; &#125; &#125; for(int i=n-2;i&gt;=0;i--)&#123; for(int j=0;j&lt;i+1;j++)&#123; num[i][j]+=max(num[i+1][j],num[i+1][j+1]); &#125; &#125; cout&lt;&lt;num[0][0];&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Axios(JS HTTP库/Ajax库)基本用法","date":"2017-04-22T12:48:28.000Z","path":"2017/04/22/Axios-JS-HTTP库-Ajax库-基本用法/","text":"Axios-JS特征vue更新到2.0之后，作者就不再对vue-resource更新了，而是推荐使用Axios。Axios的特征是： 在浏览器中发送 XMLHttpRequests 请求 比Jquery轻量，但处理请求不多时，可以使用 基于Promise语法标准 支持NodeJs 拦截请求和响应 自动转换JSON数据 客户端支持保护安全免受 XSRF 攻击 安装(没有安装npm的可以直接安装nodejs，自带npm) 安装到当前项目下：1npm install --save axios vue-axios 或全局安装：1npm install -g axios vue-axios 使用1234import Vue from &apos;vue&apos;import axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos;Vue.use(VueAxios,axios) ##例子 发送get请求12345678910111213141516171819axios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); //上下代码等同axios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送post请求12345678910axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送多个并发请求12345678910 function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // Both requests are now complete &#125;)); 可以通过给axios传递参数来制定请求12345678axios(&#123; method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;); 在Vue中使用123456789Vue.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;)this.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;)this.$http.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) 设置axios全局默认值您可以指定将应用于每个请求的配置默认值。 123axios.defaults.baseURL = &apos;https:/*api.example.com&apos;;axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; 拦截器你可以截取请求或响应在被 then 或者 catch 处理之前 12345678910111213141516171819/*添加请求拦截器*/axios.interceptors.request.use(function(config)&#123; /*在发送请求之前做某事*/ return config; &#125;，function(error)&#123; /*请求错误时做些事*/ return Promise.reject(error); &#125;);/*添加响应拦截器*/axios.interceptors.response.use(function(response)&#123; /*对响应数据做些事*/ return response; &#125;，function(error)&#123; /*请求错误时做些事*/ return Promise.reject(error); &#125;); /*如果你以后可能需要删除拦截器。*/var myInterceptor = axios.interceptors.request.use(function()&#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 取消请求您可以使用取消令牌取消请求。您可以使用CancelToken.source工厂创建一个取消令牌，如下所示：12345678910111213var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token&#125;).catch(function(thrown)&#123; if (axios.isCancel(thrown)) &#123; console.log(&apos;Request canceled&apos;, thrown.message); &#125; else &#123; /* 处理错误*/ &#125;&#125;);/*取消请求(消息参数是可选的)*/source.cancel(&apos;操作被用户取消。&apos;); 您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌： 12345678910var CancelToken = axios.CancelToken;var cancel;axios.get(&apos;/ user / 12345&apos;，&#123; cancelToken：new CancelToken(functionexecutor(c)&#123; /*一个执行器函数接收一个取消函数作为参数*/ cancel = c; &#125;)&#125;);/* 取消请求*/clear(); 注意：您可以使用相同的取消令牌取消几个请求。 axios在很大程度上受到Angular提供的$http服务的启发。 最终，axios努力提供一个在Angular外使用的独立的$http-like服务。","tags":[{"name":"axios","slug":"axios","permalink":"http://yoursite.com/tags/axios/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"入手GitHub+Hexo博客必备:MarkDown语法","date":"2017-04-19T14:06:06.000Z","path":"2017/04/19/入手GitHub-Hexo博客必备-MarkDown语法/","text":"标题设置（让字体变大，和word的标题意思一样）在Markdown当中设置标题，有两种方式：第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 块注释（blockquote）通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。） 斜体将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来 粗体将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 无序列表在文字开头添加(, +, and -)实现无序列表。但是要注意在(, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式） 有序列表使用数字后面跟上句号。（还要有空格） 链接（Links）Markdown中有两种方式，实现链接，分别为内联方式和引用方式。 1234内联方式：This is an [example link](http://example.com/).引用方式：I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ “Google” [2]: http://search.yahoo.com/ “Yahoo Search” [3]: http://search.msn.com/ “MSN Search” 图片（Images）图片的处理方式和链接的处理方式，非常的类似。 内联方式： 1![alt text](/path/to/img.jpg &quot;Title&quot;) 引用方式：12![alt text][id][id]: /path/to/img.jpg &quot;Title&quot; 代码（HTML中所谓的Code）实现方式有两种：第一种：简单文字出现一个代码框。使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~中的）第二种：大片文字需要实现代码框。使用Tab和四个空格。 脚注（footnote）实现方式如下：hello[^hello] 1[^hello]: hi 下划线在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）","tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]},{"title":"hello hexo","date":"2017-04-18T14:20:06.000Z","path":"2017/04/18/hello-hexo/","text":"#Hello Hexo 很久以前就想搭建一个个人技术博客的网站了，但是那时候接触的东西不多，没有听说过hexo、jekyll、wordpress等快速blog生成工具，自己在网上找了博客模板，修改了一下前端代码，用eclipse基于jsp搭建了一个小型博客发布到阿里云，但是时间久了发现自己写的代码不稳定，经常获取不到数据库数据，于是放弃了做个人博客网站的想法。 后来听说了hexo，但是一直没有定下心去看官方文档，于是搭博客网站的想法再一次不了了之。今晚闲暇，实在不知道该干什么，于是捡起了搭博客的想法，入门了hexo搭建github博客，现在记录下来，也算是作个念象，给想要搭建个人博客网站的小伙伴们一个参考。","tags":[]},{"title":"Hello World","date":"2017-04-18T09:53:59.501Z","path":"2017/04/18/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]