[{"title":"Netty快速入门","date":"2017-08-01T14:03:38.000Z","path":"2017/08/01/Netty快速入门/","text":"Netty是由JBOSS提供的一个java开源的、基于NIO的、异步的、事件驱动的网络应用程序框架和工具，用来快速开发高性能、高并发、高可靠的网络服务器和客户端程序，大多数用于服务端开发，为Java游戏服务器开发必学框架之一。简单来说，Netty是一个基于NIO(No-block IO)的提供了对TCP、UDP、HTTP以及文件传输的支持，通过Reactor反应器模式，可以快速开发高性能的应用程序。 上一个简单的dome： Server端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import io.netty.bootstrap.ServerBootstrap;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;public class NettyServer &#123; public void bind(int port)&#123; EventLoopGroup bossGroup=new NioEventLoopGroup(); EventLoopGroup workerGroup=new NioEventLoopGroup(); ServerBootstrap b=new ServerBootstrap(); b.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG,1024) .childHandler(new ChildChannelHandler()); try &#123; ChannelFuture f=b.bind(port).sync(); f.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125; public static void main(String[] args) &#123; int port=8989; new NettyServer().bind(port); &#125;&#125;class ChildChannelHandler extends ChannelInitializer&lt;SocketChannel&gt;&#123; public static int count=1; @Override protected void initChannel(SocketChannel arg0) throws Exception &#123; // TODO Auto-generated method stub arg0.pipeline().addLast(new NettyServerHandler()); System.out.println(&quot;connect server number: &quot;+ChildChannelHandler.count++); &#125;&#125;class NettyServerHandler extends ChannelHandlerAdapter&#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; // TODO Auto-generated method stub ByteBuf buf=(ByteBuf)msg; byte[] req=new byte[buf.readableBytes()]; buf.readBytes(req); String body=new String(req,&quot;utf-8&quot;); System.out.println(&quot;receive: &quot;+body); String toClient=&quot;hello client&quot;; ByteBuf resp=Unpooled.buffer(toClient.getBytes().length); resp.writeBytes(toClient.getBytes()); ctx.write(resp); &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; // TODO Auto-generated method stub ctx.flush(); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; // TODO Auto-generated method stub ctx.close(); &#125;&#125; Client端:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.logging.Logger;import io.netty.bootstrap.Bootstrap;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelHandlerAdapter;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;public class NettyClient &#123; public void connect(String host,int port)&#123; EventLoopGroup group=new NioEventLoopGroup(); Bootstrap b=new Bootstrap(); b.group(group) .channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;()&#123; @Override protected void initChannel(SocketChannel arg0) throws Exception &#123; // TODO Auto-generated method stub arg0.pipeline().addLast(new NettyClientHandler()); &#125; &#125;); try &#123; ChannelFuture f=b.connect(host,port).sync(); f.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; group.shutdownGracefully(); &#125; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub String host=&quot;127.0.0.1&quot;; int port=8989; new NettyClient().connect(host, port); &#125;&#125;class NettyClientHandler extends ChannelHandlerAdapter&#123; private final static Logger logger=Logger.getLogger(NettyClientHandler.class.getName()); private ByteBuf firstMessage=null; public NettyClientHandler()&#123; byte[] req=&quot;hello server&quot;.getBytes(); firstMessage=Unpooled.buffer(req.length); firstMessage.writeBytes(req); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; // TODO Auto-generated method stub ctx.writeAndFlush(firstMessage); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; // TODO Auto-generated method stub ByteBuf buf=(ByteBuf)msg; byte[] req=new byte[buf.readableBytes()]; buf.readBytes(req); String body=new String(req,&quot;utf-8&quot;); System.out.println(&quot;Now is: &quot;+body); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; // TODO Auto-generated method stub logger.warning(&quot;Logger Warning: &quot;+cause.getMessage()); //打印异常信息 ctx.close(); &#125; &#125; Server端和Client端的代码都极其相似，主要是Server用了两个NioEventLoopGroup，一个用来接受client连接，一个用来进行对SocketChannel读写。ServerBootstrap用来启动NIO服务端的辅助启动类，目的是降低服务端的开发程度。简单说一下Channel和SocketChannel，常规的TCP通信是基于Socket的，然后同过字节流的方式进行传输，效率很低，在NIO中，通过Channel这种以块的模式进行传输数据，SocketChannel是Channel中的一种用以Socket传输的方式。 在netty中，不管是客户端还是服务端，一旦建立连接，首先初始化channel，通过new一个ChannelInitializer这个类或者自己写一个外部类然后继承于这个类，并重写其中的initChannel方法，获得SocketChannel后可以通过管道的方式添加一个handler(可以是一个外部类通过继承ChannelHandlerAdapter，来实现具体的业务逻辑处理)，这里还可以添加其它中间件，比如new StringDecoder(),用来将传输的字节流数据自动转换换成字符串；以及new LineBasedFrameDecoder()或者new DeLimitFrameDecoder()等进行TCP粘包/拆包。 在上边自定义ChannelHandlerAdapter的子类中,Server端中channelRead()方法是在接收到数据时运行,channelReadComplete()方法是在数据读取完成是运行,exceptionCaught是在发生异常是运行。Client不同的是channelActive()方法是在连接成功后运行。其中发送数据都是ctx.writeAndFlush(ByteBuf),注意是发送字节，不能直接发送字符串，不然会发送不出去。 关于TCP粘包/拆包简而言之，在网络传输中，数据是基于字节流的，一次最大能发送多少个字节的数据，跟操作系统有关以及硬件配置有关，发送的数据与数据之间是没有间隔的，是连接在一起的，会出现一次发送一条数据外加另一条数据的一部分等情况，那么怎么让客户端知道读取到某的地方时该是下一条数据，通常用\\n或者\\t\\n来分辨，LineBasedFrameDecoder这个中间件就是通过\\n和\\t\\n来区分。 DeLimitFrameDecoder则是以一个自定义的字符进行区分。 使用LineBasedFrameDecoder以及StringDecoderServer: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class NettyServer &#123; public void bind(int port)&#123; EventLoopGroup bossGroup=new NioEventLoopGroup(); EventLoopGroup workerGroup=new NioEventLoopGroup(); ServerBootstrap b=new ServerBootstrap(); b.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG,1024) .childHandler(new ChildChannelHandler()); try &#123; ChannelFuture f=b.bind(port).sync(); f.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125; public static void main(String[] args) &#123; int port=8989; new NettyServer().bind(port); &#125;&#125;class ChildChannelHandler extends ChannelInitializer&lt;SocketChannel&gt;&#123; public static int count=1; @Override protected void initChannel(SocketChannel arg0) throws Exception &#123; // TODO Auto-generated method stub arg0.pipeline().addLast(new StringDecoder()); arg0.pipeline().addLast(new LineBasedFrameDecoder(1024)); arg0.pipeline().addLast(new NettyServerHandler()); System.out.println(&quot;connect server number: &quot;+ChildChannelHandler.count++); &#125;&#125;class NettyServerHandler extends ChannelHandlerAdapter&#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; // TODO Auto-generated method stub String buf=(String)msg; System.out.println(&quot;receive: &quot;+buf); String toClient=&quot;hello client\\n&quot;; ByteBuf resp=Unpooled.buffer(toClient.getBytes().length); resp.writeBytes(toClient.getBytes()); ctx.write(resp); &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; // TODO Auto-generated method stub ctx.flush(); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; // TODO Auto-generated method stub ctx.close(); &#125;&#125; Client:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class NettyClient &#123; public void connect(String host,int port)&#123; EventLoopGroup group=new NioEventLoopGroup(); Bootstrap b=new Bootstrap(); b.group(group) .channel(NioSocketChannel.class) .option(ChannelOption.TCP_NODELAY, true) .handler(new ChannelInitializer&lt;SocketChannel&gt;()&#123; @Override protected void initChannel(SocketChannel arg0) throws Exception &#123; // TODO Auto-generated method stub arg0.pipeline().addLast(new StringDecoder()); arg0.pipeline().addLast(new LineBasedFrameDecoder(1024)); arg0.pipeline().addLast(new NettyClientHandler()); &#125; &#125;); try &#123; ChannelFuture f=b.connect(host,port).sync(); f.channel().closeFuture().sync(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; group.shutdownGracefully(); &#125; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub String host=&quot;127.0.0.1&quot;; int port=8989; new NettyClient().connect(host, port); &#125;&#125;class NettyClientHandler extends ChannelHandlerAdapter&#123; private final static Logger logger=Logger.getLogger(NettyClientHandler.class.getName()); private ByteBuf firstMessage=null; public NettyClientHandler()&#123; byte[] req=&quot;hello server\\n&quot;.getBytes(); firstMessage=Unpooled.buffer(req.length); firstMessage.writeBytes(req); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; // TODO Auto-generated method stub ctx.writeAndFlush(firstMessage); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; // TODO Auto-generated method stub String buf=(String)msg; System.out.println(&quot;Now is: &quot;+buf); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; // TODO Auto-generated method stub logger.warning(&quot;Logger Warning: &quot;+cause.getMessage()); ctx.close(); &#125; &#125; 注意使用LineBasedFrameDecoder后记得在发送的数据后边加\\n,使用StringDecoder后，在channelRead方法里边的msg自动被转换成了字符串，但是发送数据时，仍然要发送字节流数据。","tags":[{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"}]},{"title":"Java IO:RandomAccessFile","date":"2017-07-13T13:50:52.000Z","path":"2017/07/13/Java-IO-RandomAccessFile/","text":"在Java中RandomAccessFile可以对文件进行随机的访问操作，包括读和写，具有两个访问模式，一个是只读(r)，一个是读写(rw),需要在创建RandomAccessFile对象时传入参数进行设置，第一个参数是文件路径，第二个参数为访问模式。该类读写是基于指针的操作。 创建一个RandomAccessFile对象进行读写1234RandomAccessFile file=new RandomAccessFile(&quot;D:\\\\file.txt&quot;,&quot;rw&quot;);int data=file.read();file.write(&quot;hello world&quot;.getBytes());file.close(); read()方法会返回当前指针所指向位置的字节内容，read()在读取完一个字节后，会自动把指针移向下一个位置。同样,write()方法在调用完之后也会自动移动指针。 在RandomAccessFile中进行来回读写1234RandomAccessFile file=new RandomAccessFile(&quot;D:\\\\file.txt&quot;,&quot;rw&quot;);file.seek(200);long pointer=file.getFilePointer();file.close(); 通过seek()方法可以设置指针位置，getFilePointer()方法可以返回当前指针所在位置。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JS中DOM操作、事件绑定、监听、委托及event对象详解","date":"2017-05-06T10:57:47.000Z","path":"2017/05/06/JS中DOM操作、事件绑定、监听、委托及event对象详解/","text":"在JavaScript中最不得不提起的就是对DOM节点的操作以及它的事件机制，对于其中的细节之处，往往是一个前端开发者必须要掌握的。 DOM操作1.访问节点document.getElementById(id);返回对拥有指定id的第一个对象进行访问 document.getElementsByName(name);返回带有指定名称的节点集合注意:Elements document.getElementsByTagName(tagname);返回带有指定标签名的对象集合注意：Elements document.getElementsByClassName(classname);返回带有指定class名称的对象集合 2.生成节点document.createElement(eName);创建一个节点 document.createAttribute(attrName);对某个节点创建属性 document.createTextNode(text);创建文本节点 3.添加节点document.insertBefore(newNode,referenceChild);在某个节点前插入节点 parentNode.appendChild(newNode);给某个节点添加子节点 4.复制节点cloneNode(true | false);复制某个节点参数：是否复制原节点的所有属性 5.删除节点parentNode.removeChild(node)删除某个节点的子节点node是要删除的节点 6.修改文本节点appendData(data);将data加到文本节点后面 deleteData(start,length);将从start处删除length个字符 insertData(start,data)在start处插入字符,start的开始值是0; replaceData(start,length,data)在start处用data替换length个字符 splitData(offset)在offset处分割文本节点 substringData(start,length)从start处提取length个字符 7.属性操作getAttribute(name)通过属性名称获取某个节点属性的值 setAttribute(name,value);修改某个节点属性的值 removeAttribute(name)删除某个属性 8.查找节点parentObj.firstChild如果节点为已知节点的第一个子节点就可以使用这个方法。此方法可以递归进行使用parentObj.firstChild.firstChild….. parentObj.lastChild获得一个节点的最后一个节点，与firstChild一样也可以进行递归使用parentObj.lastChild.lastChild….. parentObj.childNodes获得节点的所有子节点，然后通过循环和索引找到目标节点 9.获取相邻的节点neborNode.previousSibling :获取已知节点的相邻的上一个节点nerbourNode.nextSlbling: 获取已知节点的下一个节点 10.获取父节点childNode.parentNode:得到已知节点的父节点 11替换节点方法replace(new,old) JS innerHTML和innerText区别1、innerHTML: 也就是从对象的起始位置到终止位置的全部内容,包括Html标签。2、innerText: 从起始位置到终止位置的内容, 但它去除Html标签 事件机制总所周知，在JavaScript中事件采用绑定监听这种形式。我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等 在JavaScript代码中绑定事件123456&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn&quot;).onclick = function()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 在html中添加事件函数123456&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn&quot; onclick=&quot;btnClick()&quot;&gt;&lt;script&gt;function btnClick()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 绑定事件监听器W3C规范 语法： element.addEventListener(event, function, useCapture) event : （必需）事件名，支持所有 DOM事件 。 function：（必需）指定要事件触发时执行的函数。 useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。注：IE8以下不支持。 IE标准 语法： element.attachEvent(event, function) event：（必需）事件类型。需加“on“，例如：onclick。 function：（必需）指定要事件触发时执行的函数。1234567&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn&quot;&gt;&lt;script&gt;document.getElementById(&apos;btn&apos;).addEventListener(&quot;click&quot;, btnClick, false);function btnClick()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 移除事件element.removeEventListener(event,function);IE下：element.detachEvent(event,function); 事件模型但值得注意的是JavaScript中事件模型分为两种————冒泡模型和捕获模型，也称事件冒泡和事件捕获。（1）事件冒泡：指事件按照从最特定的事件目标到最不特定的事件目标的顺序触发。通俗一点，在html文档中，DOM节点成呈树状结构，从最特点的事件目标即直接发生的DOM节点到最不特点发生的事件目标即html的document对象传递，这个过程称为事件冒泡。（2）事件捕获：事件从最不精确的document对象开始触发，到最特定最精确的事件目标。简而言之，就是和事件冒泡完全相反的两个动作。（3）DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。DOM事件模型最独特的性质是，文本节点也触发事件(在IE中不会)。 事件委托事件委托就是利用冒泡的原理，把事件加给父元素或祖先元素上，触发执行效果。事件委托的有点，可以避免多个同类型节点添加同一事件处理，减少内存占用，提高事件的处理速度，优化网页性能。 比如给一个里边的每一项添加事件： 传统写法：1234567891011121314&lt;ul id=&quot;group&quot;&gt; &lt;li&gt;item1&lt;/li&gt; &lt;li&gt;item2&lt;/li&gt; &lt;li&gt;item3&lt;/li&gt; &lt;li&gt;item4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var items=document.getElementsByTagName(&apos;li&apos;); for(var i=0;i&lt;items.length;i++)&#123; items[i].onclick=function()&#123; this.style.color=&apos;red&apos;; &#125; &#125;&lt;/script&gt; 事件委托写法：12345678910111213&lt;ul id=&quot;group&quot;&gt; &lt;li&gt;item1&lt;/li&gt; &lt;li&gt;item2&lt;/li&gt; &lt;li&gt;item3&lt;/li&gt; &lt;li&gt;item4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var group=document.getElementById(&apos;group&apos;); group.onclick=function(event)&#123; var target=event.target; target.style.color=&apos;red&apos;; &#125;&lt;/script&gt; 当然函数阻止事件冒泡可以使用event.stopPropagation().还有阻止事件的默认行为的方法有event.preventDefault() Event对象 type：事件的类型，如onlick中的click； srcElement/target：事件源，就是发生事件的元素； button：声明被按下的鼠标键，整数，1代表左键，2代表右键，4代表中键，如果按下多个键，酒把这些值加起来，所以3就代表左右键同时按下；（firefox中 0代表左键，1代表中间键，2代表右键） clientX/clientY：事件发生的时候，鼠标相对于浏览器窗口可视文档区域的左上角的位置；(在DOM标准中，这两个属性值都不考虑文档的滚动情况，也就是说，无论文档滚动到哪里，只要事件发生在窗口左上角，clientX和clientY都是 0，所以在IE中，要想得到事件发生的坐标相对于文档开头的位置，要加上document.body.scrollLeft和 document.body.scrollTop) offsetX,offsetY/layerX,layerY：事件发生的时候，鼠标相对于源元素左上角的位置； x,y/pageX,pageY：检索相对于父要素鼠标水平坐标的整数； altKey,ctrlKey,shiftKey等：返回一个布尔值； keyCode：返回keydown何keyup事件发生的时候按键的代码，以及keypress 事件的Unicode字符；(firefox2不支持 event.keycode，可以用 event.which替代 ) fromElement,toElement：前者是指代mouseover事件中鼠标移动过的文档元素，后者指代mouseout事件中鼠标移动到的文档元素； cancelBubble：一个布尔属性，把它设置为true的时候，将停止事件进一步起泡到包容层次的元素；(e.cancelBubble = true; 相当于 e.stopPropagation();) returnValue：一个布尔属性，设置为false的时候可以组织浏览器执行默认的事件动作；(e.returnValue = false; 相当于 e.preventDefault();) attachEvent(),detachEvent()/addEventListener(),removeEventListener：为制定 DOM对象事件类型注册多个事件处理函数的方法，它们有两个参数，第一个是事件类型，第二个是事件处理函数。在attachEvent()事件执行的时候，this关键字指向的是window对象，而不是发生事件的那个元素； screenX、screenY：鼠标指针相对于显示器左上角的位置，如果你想打开新的窗口，这两个属性很重要；","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"算法学习笔记-妖怪与和尚过河问题","date":"2017-05-04T14:21:31.000Z","path":"2017/05/04/算法学习笔记-妖怪与和尚过河问题/","text":"有三个和尚（或传教士）和三个妖怪（或食人怪）过河，只有一条能装下两个人（和尚或妖怪）的船，在河的任何一方或者船上，如果妖怪的人数大于和尚的人数，那么和尚就会有被吃掉的危险。你能不能找出一种安全的渡河方法呢？ 这是一个很有意思的智力题，但是并不难，每次可以选择一个人或者两个人过河，只要保证河的任何一边的和尚数量总是大于或等于妖怪的数量即可。这里先给出一种过河方法： 两个妖怪先过河，一个妖怪回来； 再两个妖怪过河，一个妖怪回来； 两个和尚过河，一个妖怪和一个和尚回来； 两个和尚过河，一个妖怪回来； 两个妖怪过河，一个妖怪回来； 两个妖怪过河。 总共要过河11次 过河的方法其实不止这一种，本文给出了一种求解全部过河方法的算法程序，可以通过穷举（状态树搜索）的方法得到全部四种过河方法。 解决问题的思路题目的初始条件是三个和尚和三个妖怪在河的一边（还有一条船），解决问题后的终止条件是三个和尚和三个妖怪安全地过到河的对岸，如果把任意时刻妖怪和和尚的位置看作一个“状态”，则解决问题就是找到一条从初始状态变换到终止状态的路径。从初始状态开始，每选择一批妖怪或和尚过河（移动一次小船），就会从原状态产生一个新的状态，如果以人类思维解决这个问题，每次都会选择最佳的妖怪与和尚组合过河，使得它们过河后生成的新状态更接近最终状态，不断重复上述过程，直到得到最终状态。用计算机解决妖怪与和尚过河问题的思路也是通过状态转换，找到一条从初始状态到结束状态的转换路径。计算机不会进行理性分析，不知道每次如何选择最佳的过河方式，但是计算机擅长快速计算且不知疲劳，既然不知道如何选择过河方式，那就干脆把所有的过河方式都尝试一遍，找出所有可能的结果，当然也就包括成功过河的结果。 c++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt; #include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;//抽象过河状态 struct State&#123; int local_monk=3; int local_monster=3; int remote_monk=0; int remote_monster=0; int i_boat=0;&#125;;int c=0; //计算次数 int m=999;int boat=0; //船的位置 0在原岸 1在对岸 int action[10][3]=&#123;&#123;0,-1,0&#125;,&#123;0,-2,0&#125;,&#123;0,0,-1&#125;,&#123;0,0,-2&#125;,&#123;0,-1,-1&#125;,&#123;1,1,0&#125;,&#123;1,2,0&#125;,&#123;1,0,1&#125;,&#123;1,0,2&#125;,&#123;1,1,1&#125;&#125;; //定义行动数组 vector&lt;State&gt; vi;//打印结果void printResullt()&#123; cout&lt;&lt;endl; for(int i=0;i&lt;vi.size();i++)&#123; State s=vi[i]; cout&lt;&lt;s.i_boat&lt;&lt;&quot; &quot;&lt;&lt;s.local_monk&lt;&lt;&quot; &quot;&lt;&lt;s.local_monster&lt;&lt;&quot; &quot;&lt;&lt;s.remote_monk&lt;&lt;&quot; &quot;&lt;&lt;s.remote_monster&lt;&lt;endl; &#125; cout&lt;&lt;endl;&#125;bool isFinalState(State state)&#123; if(state.local_monk==0 &amp;&amp; state.local_monster==0 &amp;&amp; state.remote_monk==3 &amp;&amp; state.remote_monster==3)&#123; printResullt(); //输出结果集合里边的所有状态 if(c&lt;m)&#123; m=c; &#125; return true; &#125;else&#123; return false; &#125;&#125;bool isEffective(State state)&#123; if((state.local_monk&gt;=state.local_monster &amp;&amp; state.remote_monk&gt;=state.remote_monster) || state.local_monk==0 || state.remote_monk==0)&#123; return true; &#125;else&#123; return false; &#125;&#125;bool isEmpty(State st)&#123; int n=0; for(int i=0;i&lt;vi.size();i++)&#123; State s=vi[i]; if(s.local_monk==st.local_monk &amp;&amp; s.local_monster==st.local_monster &amp;&amp; s.remote_monk==st.remote_monk &amp;&amp; s.remote_monster==st.remote_monster &amp;&amp; s.i_boat==st.i_boat)&#123; n++; &#125; &#125; if(n&gt;=2)&#123; return true; &#125; return false;&#125;void search()&#123; State state=vi.back(); if(isEmpty(state) &amp;&amp; vi.size()&gt;1)&#123; return; &#125; if(isFinalState(state))&#123; return; &#125; for(int i=0;i&lt;10;i++)&#123; state=vi.back(); if(action[i][0]==boat)&#123; if((boat==0 &amp;&amp; state.local_monk&gt;=abs(action[i][1]) &amp;&amp; state.local_monster&gt;=abs(action[i][2])) || (boat==1 &amp;&amp; state.remote_monk&gt;=abs(action[i][1]) &amp;&amp; state.remote_monster&gt;=abs(action[i][2])))&#123; state.local_monk+=action[i][1]; state.local_monster+=action[i][2]; state.remote_monk-=action[i][1]; state.remote_monster-=action[i][2]; if(isEffective(state))&#123; boat=(++boat)%2; state.i_boat=boat; vi.push_back(state); c++; search(); vi.pop_back(); boat=(++boat)%2; c--; &#125; &#125; &#125; &#125;&#125;int main()&#123; State state; vi.push_back(state); search(); cout&lt;&lt;&quot;最少过河次数为：&quot;&lt;&lt;m&lt;&lt;endl;&#125; 在这道题中，过河这种动作共有5种动作，加上船在不同的两岸，所以需要乘2，一共10种情况。可利用深度优先进行遍历每一种状态生产状态树，不过由于深度优先可能会陷入状态回路中，所以需要从每次加入状态的集合里边判断是否有相同状态，对了，值得注意的是，船的状态也要判断，由于本人之前没判断船的状态，结果一直陷入调BUG中。","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"状态树","slug":"状态树","permalink":"http://yoursite.com/tags/状态树/"}]},{"title":"css3动画库animate.css的使用","date":"2017-04-23T14:40:20.000Z","path":"2017/04/23/css3动画库animate-css的使用/","text":"简介 animate.css 是一个来自国外的 CSS3 动画库，它预设了抖动（shake）、闪烁（flash）、弹跳（bounce）、翻转（flip）、旋转（rotateIn/rotateOut）、淡入淡出（fadeIn/fadeOut）等多达 60 多种动画效果，几乎包含了所有常见的动画效果。虽然借助 animate.css 能够很方便、快速的制作 CSS3 动画效果，但还是建议看看 animate.css 的代码，也许你能从中学到一些东西。 兼容 浏览器兼容：当然是只兼容支持 CSS3 animate 属性的浏览器，他们分别是：IE10+、Firefox、Chrome、Opera、Safari。 下载http://daneden.github.io/animate.css/ 使用方法1.引入文件及使用1&lt;link rel=&quot;stylesheet&quot; href=&quot;animate.min.css&quot;&gt; 1&lt;div class=&quot;animated bounce&quot; id=&quot;dowebok&quot;&gt;&lt;/div&gt; 搭配jquery 给元素加上 class 后，刷新页面，就能看到动画效果了。animated 类似于全局变量，它定义了动画的持续时间；bounce 是动画具体的动画效果的名称，你可以选择任意的效果。 如果动画是无限播放的，可以添加 class infinite。 你也可以通过 JavaScript 或 jQuery 给元素添加这些 class，比如：123$(function()&#123; $(&apos;#dowebok&apos;).addClass(&apos;animated bounce&apos;);&#125;); 有些动画效果最后会让元素不可见，比如淡出、向左滑动等等，可能你又需要将 class 删除，比如：（刚看到有些人直接复制了下边的代码没显示，原因是没添加触发事件，可以加一个hover/点击事件，把下面的代码复制进去，或者可以直接写123456$(function()&#123; $(&apos;#dowebok&apos;).addClass(&apos;animated bounce&apos;); setTimeout(function()&#123; $(&apos;#dowebok&apos;).removeClass(&apos;bounce&apos;); &#125;, 1000);&#125;); animate.css 的默认设置也许有些时候并不是我们想要的，所以你可以重新设置，比如： 12345#dowebok &#123; animate-duration: 2s; //动画持续时间 animate-delay: 1s; //动画延迟时间 animate-iteration-count: 2; //动画执行次数&#125;","tags":[{"name":"animate.css","slug":"animate-css","permalink":"http://yoursite.com/tags/animate-css/"},{"name":"css3动画","slug":"css3动画","permalink":"http://yoursite.com/tags/css3动画/"}]},{"title":"算法学习笔记-DP动态规划","date":"2017-04-23T13:12:39.000Z","path":"2017/04/23/算法学习笔记-DP动态规划/","text":"动态规划相信大家都知道，动态规划算法也是新手在刚接触算法设计时很苦恼的问题，有时候觉得难以理解，但是真正理解之后，就会觉得动态规划其实并没有想象中那么难。网上也有很多关于讲解动态规划的文章，大多都是叙述概念，讲解原理，让人觉得晦涩难懂，即使一时间看懂了，发现当自己做题的时候又会觉得无所适从。我觉得，理解算法最重要的还是在于练习，只有通过自己练习，才可以更快地提升。话不多说，接下来，下面我就通过一个例子来一步一步讲解动态规划是怎样使用的，只有知道怎样使用，才能更好地理解，而不是一味地对概念和原理进行反复琢磨。 能用动规解决的问题的特点 问题具有最优子结构性质。如果问题的最优解所包含的 子问题的解也是最优的，我们就称该问题具有最优子结 构性质。 无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。 首先，我们来看一道题:数值三角形 7 3 88 1 02 7 4 44 5 2 6 5 在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99 输入格式： 5 //表示三角形的行数 接下来输入三角形 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 要求输出最大和 首先看到这道题，由于本人习惯了深度优先搜索的方式去处理问题，所以首先下意识的就想到深度优先搜索。 深度优先搜索代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int num[100][100],book[100][100];int direct[2][2]=&#123;&#123;1,0&#125;,&#123;1,1&#125;&#125;; //定义方向数组 int n;int m=0; //最大和 void func(int x,int y)&#123; if(x&gt;=n)&#123; int sum=0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(book[i][j]!=0)&#123; sum+=num[i][j]; &#125; &#125; &#125; if(sum&gt;m)&#123; m=sum; &#125; return; &#125; for(int i=0;i&lt;2;i++)&#123; if(book[x][y]==0)&#123; book[x][y]=1; func(x+direct[i][0],y+direct[i][1]); book[x][y]=0; &#125; &#125;&#125;int main()&#123; memset(num,0,sizeof(num)); memset(book,0,sizeof(book)); cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;i+1;j++)&#123; cin&gt;&gt;num[i][j]; &#125; &#125; func(0,0); cout&lt;&lt;m&lt;&lt;endl;&#125; 下面看动态规划代码: 动态规划代码1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int num[n][n]; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;i+1;j++)&#123; cin&gt;&gt;num[i][j]; &#125; &#125; for(int i=n-2;i&gt;=0;i--)&#123; for(int j=0;j&lt;i+1;j++)&#123; num[i][j]+=max(num[i+1][j],num[i+1][j+1]); &#125; &#125; cout&lt;&lt;num[0][0];&#125; 显而易见，动态规划这种方法的时间复杂度明显比深度优先高，所以在考虑此类问题时，为了追求更好的时间复杂度，可以选用动态规划。","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Axios(JS HTTP库/Ajax库)基本用法","date":"2017-04-22T12:48:28.000Z","path":"2017/04/22/Axios-JS-HTTP库-Ajax库-基本用法/","text":"特征vue更新到2.0之后，作者就不再对vue-resource更新了，而是推荐使用Axios。Axios的特征是： 在浏览器中发送 XMLHttpRequests 请求 比Jquery轻量，但处理请求不多时，可以使用 基于Promise语法标准 支持NodeJs 拦截请求和响应 自动转换JSON数据 客户端支持保护安全免受 XSRF 攻击 安装(没有安装npm的可以直接安装nodejs，自带npm) 安装到当前项目下：1npm install --save axios vue-axios 或全局安装：1npm install -g axios vue-axios 使用1234import Vue from &apos;vue&apos;import axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos;Vue.use(VueAxios,axios) 例子发送get请求12345678910111213141516171819axios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); //上下代码等同axios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送post请求12345678910axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送多个并发请求12345678910 function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // Both requests are now complete &#125;)); 可以通过给axios传递参数来制定请求12345678axios(&#123; method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;); 在Vue中使用123456789Vue.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;)this.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;)this.$http.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) 设置axios全局默认值您可以指定将应用于每个请求的配置默认值。 123axios.defaults.baseURL = &apos;https:/*api.example.com&apos;;axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; 拦截器你可以截取请求或响应在被 then 或者 catch 处理之前 12345678910111213141516171819/*添加请求拦截器*/axios.interceptors.request.use(function(config)&#123; /*在发送请求之前做某事*/ return config; &#125;，function(error)&#123; /*请求错误时做些事*/ return Promise.reject(error); &#125;);/*添加响应拦截器*/axios.interceptors.response.use(function(response)&#123; /*对响应数据做些事*/ return response; &#125;，function(error)&#123; /*请求错误时做些事*/ return Promise.reject(error); &#125;); /*如果你以后可能需要删除拦截器。*/var myInterceptor = axios.interceptors.request.use(function()&#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 取消请求您可以使用取消令牌取消请求。您可以使用CancelToken.source工厂创建一个取消令牌，如下所示：12345678910111213var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token&#125;).catch(function(thrown)&#123; if (axios.isCancel(thrown)) &#123; console.log(&apos;Request canceled&apos;, thrown.message); &#125; else &#123; /* 处理错误*/ &#125;&#125;);/*取消请求(消息参数是可选的)*/source.cancel(&apos;操作被用户取消。&apos;); 您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌： 12345678910var CancelToken = axios.CancelToken;var cancel;axios.get(&apos;/ user / 12345&apos;，&#123; cancelToken：new CancelToken(functionexecutor(c)&#123; /*一个执行器函数接收一个取消函数作为参数*/ cancel = c; &#125;)&#125;);/* 取消请求*/clear(); 注意：您可以使用相同的取消令牌取消几个请求。 axios在很大程度上受到Angular提供的$http服务的启发。 最终，axios努力提供一个在Angular外使用的独立的$http-like服务。","tags":[{"name":"axios","slug":"axios","permalink":"http://yoursite.com/tags/axios/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"入手GitHub+Hexo博客必备:MarkDown语法","date":"2017-04-19T14:06:06.000Z","path":"2017/04/19/入手GitHub-Hexo博客必备-MarkDown语法/","text":"标题设置（让字体变大，和word的标题意思一样）在Markdown当中设置标题，有两种方式：第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 块注释（blockquote）通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。） 斜体将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来 粗体将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 无序列表在文字开头添加(, +, and -)实现无序列表。但是要注意在(, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式） 有序列表使用数字后面跟上句号。（还要有空格） 链接（Links）Markdown中有两种方式，实现链接，分别为内联方式和引用方式。 1234内联方式：This is an [example link](http://example.com/).引用方式：I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ “Google” [2]: http://search.yahoo.com/ “Yahoo Search” [3]: http://search.msn.com/ “MSN Search” 图片（Images）图片的处理方式和链接的处理方式，非常的类似。 内联方式： 1![alt text](/path/to/img.jpg &quot;Title&quot;) 引用方式：12![alt text][id][id]: /path/to/img.jpg &quot;Title&quot; 代码（HTML中所谓的Code）实现方式有两种：第一种：简单文字出现一个代码框。使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~中的）第二种：大片文字需要实现代码框。使用Tab和四个空格。 脚注（footnote）实现方式如下：hello[^hello] 1[^hello]: hi 下划线在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）","tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]},{"title":"hello hexo","date":"2017-04-18T14:20:06.000Z","path":"2017/04/18/hello-hexo/","text":"#Hello Hexo 很久以前就想搭建一个个人技术博客的网站了，但是那时候接触的东西不多，没有听说过hexo、jekyll、wordpress等快速blog生成工具，自己在网上找了博客模板，修改了一下前端代码，用eclipse基于jsp搭建了一个小型博客发布到阿里云，但是时间久了发现自己写的代码不稳定，经常获取不到数据库数据，于是放弃了做个人博客网站的想法。 后来听说了hexo，但是一直没有定下心去看官方文档，于是搭博客网站的想法再一次不了了之。今晚闲暇，实在不知道该干什么，于是捡起了搭博客的想法，入门了hexo搭建github博客，现在记录下来，也算是作个念象，给想要搭建个人博客网站的小伙伴们一个参考。","tags":[]},{"title":"Hello World","date":"2017-04-18T09:53:59.501Z","path":"2017/04/18/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]