[{"title":"JS中DOM操作、事件绑定、监听、委托详解","date":"2017-05-06T10:57:47.000Z","path":"2017/05/06/JS中DOM操作、事件绑定、监听、委托详解/","text":"在JavaScript中最不得不提起的就是对DOM节点的操作以及它的事件机制，对于其中的细节之处，往往是一个前端开发者必须要掌握的。 DOM操作1.访问节点document.getElementById(id);返回对拥有指定id的第一个对象进行访问 document.getElementsByName(name);返回带有指定名称的节点集合注意:Elements document.getElementsByTagName(tagname);返回带有指定标签名的对象集合注意：Elements document.getElementsByClassName(classname);返回带有指定class名称的对象集合 2.生成节点document.createElement(eName);创建一个节点 document.createAttribute(attrName);对某个节点创建属性 document.createTextNode(text);创建文本节点 3.添加节点document.insertBefore(newNode,referenceChild);在某个节点前插入节点 parentNode.appendChild(newNode);给某个节点添加子节点 4.复制节点cloneNode(true | false);复制某个节点参数：是否复制原节点的所有属性 5.删除节点parentNode.removeChild(node)删除某个节点的子节点node是要删除的节点 6.修改文本节点appendData(data);将data加到文本节点后面 deleteData(start,length);将从start处删除length个字符 insertData(start,data)在start处插入字符,start的开始值是0; replaceData(start,length,data)在start处用data替换length个字符 splitData(offset)在offset处分割文本节点 substringData(start,length)从start处提取length个字符 7.属性操作getAttribute(name)通过属性名称获取某个节点属性的值 setAttribute(name,value);修改某个节点属性的值 removeAttribute(name)删除某个属性 8.查找节点parentObj.firstChild如果节点为已知节点的第一个子节点就可以使用这个方法。此方法可以递归进行使用parentObj.firstChild.firstChild….. parentObj.lastChild获得一个节点的最后一个节点，与firstChild一样也可以进行递归使用parentObj.lastChild.lastChild….. parentObj.childNodes获得节点的所有子节点，然后通过循环和索引找到目标节点 9.获取相邻的节点neborNode.previousSibling :获取已知节点的相邻的上一个节点nerbourNode.nextSlbling: 获取已知节点的下一个节点 10.获取父节点childNode.parentNode:得到已知节点的父节点 11替换节点方法replace(new,old) JS innerHTML和innerText区别1、innerHTML: 也就是从对象的起始位置到终止位置的全部内容,包括Html标签。2、innerText: 从起始位置到终止位置的内容, 但它去除Html标签 事件机制总所周知，在JavaScript中事件采用绑定监听这种形式。我们可以在DOM元素上绑定onclick、onmouseover、onmouseout、onmousedown、onmouseup、ondblclick、onkeydown、onkeypress、onkeyup等 在JavaScript代码中绑定事件123456&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn&quot;&gt;&lt;script&gt;document.getElementById(&quot;btn&quot;).onclick = function()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 在html中添加事件函数123456&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn&quot; onclick=&quot;btnClick()&quot;&gt;&lt;script&gt;function btnClick()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 绑定事件监听器W3C规范 语法： element.addEventListener(event, function, useCapture) event : （必需）事件名，支持所有 DOM事件 。 function：（必需）指定要事件触发时执行的函数。 useCapture：（可选）指定事件是否在捕获或冒泡阶段执行。true，捕获。false，冒泡。默认false。注：IE8以下不支持。 IE标准 语法： element.attachEvent(event, function) event：（必需）事件类型。需加“on“，例如：onclick。 function：（必需）指定要事件触发时执行的函数。1234567&lt;input type=&quot;button&quot; value=&quot;click me&quot; id=&quot;btn&quot;&gt;&lt;script&gt;document.getElementById(&apos;btn&apos;).addEventListener(&quot;click&quot;, btnClick, false);function btnClick()&#123; alert(&quot;hello world!&quot;);&#125;&lt;/script&gt; 移除事件element.removeEventListener(event,function); 事件模型但值得注意的是JavaScript中事件模型分为两种————冒泡模型和捕获模型，也称事件冒泡和事件捕获。 （1）事件冒泡：指事件按照从最特定的事件目标到最不特定的事件目标的顺序触发。通俗一点，在html文档中，DOM节点成呈树状结构，从最特点的事件目标即直接发生的DOM节点到最不特点发生的事件目标即html的document对象传递，这个过程称为事件冒泡。 （2）事件捕获：事件从最不精确的document对象开始触发，到最特定最精确的事件目标。简而言之，就是和事件冒泡完全相反的两个动作。 （3）DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。 DOM事件模型最独特的性质是，文本节点也触发事件(在IE中不会)。 事件委托事件委托就是利用冒泡的原理，把事件加给父元素或祖先元素上，触发执行效果。事件委托的有点，可以避免多个同类型节点添加同一事件处理，减少内存占用，提高事件的处理速度，优化网页性能。 比如给一个里边的每一项添加事件： 传统写法：1234567891011121314&lt;ul id=&quot;group&quot;&gt; &lt;li&gt;item1&lt;/li&gt; &lt;li&gt;item2&lt;/li&gt; &lt;li&gt;item3&lt;/li&gt; &lt;li&gt;item4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var items=document.getElementsByTagName(&apos;li&apos;); for(var i=0;i&lt;items.length;i++)&#123; items[i].onclick=function()&#123; this.style.color=&apos;red&apos;; &#125; &#125;&lt;/script&gt; 事件委托写法：12345678910111213&lt;ul id=&quot;group&quot;&gt; &lt;li&gt;item1&lt;/li&gt; &lt;li&gt;item2&lt;/li&gt; &lt;li&gt;item3&lt;/li&gt; &lt;li&gt;item4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var group=document.getElementById(&apos;group&apos;); group.onclick=function(event)&#123; var target=event.target; target.style.color=&apos;red&apos;; &#125;&lt;/script&gt; 当然函数阻止事件冒泡可以使用event.stopPropagation().还有阻止事件的默认行为的方法有event.preventDefault()","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"算法学习笔记-妖怪与和尚过河问题","date":"2017-05-04T14:21:31.000Z","path":"2017/05/04/算法学习笔记-妖怪与和尚过河问题/","text":"妖怪与和尚过河问题 有三个和尚（或传教士）和三个妖怪（或食人怪）过河，只有一条能装下两个人（和尚或妖怪）的船，在河的任何一方或者船上，如果妖怪的人数大于和尚的人数，那么和尚就会有被吃掉的危险。你能不能找出一种安全的渡河方法呢？ 这是一个很有意思的智力题，但是并不难，每次可以选择一个人或者两个人过河，只要保证河的任何一边的和尚数量总是大于或等于妖怪的数量即可。这里先给出一种过河方法： 两个妖怪先过河，一个妖怪回来； 再两个妖怪过河，一个妖怪回来； 两个和尚过河，一个妖怪和一个和尚回来； 两个和尚过河，一个妖怪回来； 两个妖怪过河，一个妖怪回来； 两个妖怪过河。 总共要过河11次 过河的方法其实不止这一种，本文给出了一种求解全部过河方法的算法程序，可以通过穷举（状态树搜索）的方法得到全部四种过河方法。 解决问题的思路题目的初始条件是三个和尚和三个妖怪在河的一边（还有一条船），解决问题后的终止条件是三个和尚和三个妖怪安全地过到河的对岸，如果把任意时刻妖怪和和尚的位置看作一个“状态”，则解决问题就是找到一条从初始状态变换到终止状态的路径。从初始状态开始，每选择一批妖怪或和尚过河（移动一次小船），就会从原状态产生一个新的状态，如果以人类思维解决这个问题，每次都会选择最佳的妖怪与和尚组合过河，使得它们过河后生成的新状态更接近最终状态，不断重复上述过程，直到得到最终状态。用计算机解决妖怪与和尚过河问题的思路也是通过状态转换，找到一条从初始状态到结束状态的转换路径。计算机不会进行理性分析，不知道每次如何选择最佳的过河方式，但是计算机擅长快速计算且不知疲劳，既然不知道如何选择过河方式，那就干脆把所有的过河方式都尝试一遍，找出所有可能的结果，当然也就包括成功过河的结果。 c++代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt; #include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;//抽象过河状态 struct State&#123; int local_monk=3; int local_monster=3; int remote_monk=0; int remote_monster=0; int i_boat=0;&#125;;int c=0; //计算次数 int m=999;int boat=0; //船的位置 0在原岸 1在对岸 int action[10][3]=&#123;&#123;0,-1,0&#125;,&#123;0,-2,0&#125;,&#123;0,0,-1&#125;,&#123;0,0,-2&#125;,&#123;0,-1,-1&#125;,&#123;1,1,0&#125;,&#123;1,2,0&#125;,&#123;1,0,1&#125;,&#123;1,0,2&#125;,&#123;1,1,1&#125;&#125;; //定义行动数组 vector&lt;State&gt; vi;//打印结果void printResullt()&#123; cout&lt;&lt;endl; for(int i=0;i&lt;vi.size();i++)&#123; State s=vi[i]; cout&lt;&lt;s.i_boat&lt;&lt;&quot; &quot;&lt;&lt;s.local_monk&lt;&lt;&quot; &quot;&lt;&lt;s.local_monster&lt;&lt;&quot; &quot;&lt;&lt;s.remote_monk&lt;&lt;&quot; &quot;&lt;&lt;s.remote_monster&lt;&lt;endl; &#125; cout&lt;&lt;endl;&#125;bool isFinalState(State state)&#123; if(state.local_monk==0 &amp;&amp; state.local_monster==0 &amp;&amp; state.remote_monk==3 &amp;&amp; state.remote_monster==3)&#123; printResullt(); //输出结果集合里边的所有状态 if(c&lt;m)&#123; m=c; &#125; return true; &#125;else&#123; return false; &#125;&#125;bool isEffective(State state)&#123; if((state.local_monk&gt;=state.local_monster &amp;&amp; state.remote_monk&gt;=state.remote_monster) || state.local_monk==0 || state.remote_monk==0)&#123; return true; &#125;else&#123; return false; &#125;&#125;bool isEmpty(State st)&#123; int n=0; for(int i=0;i&lt;vi.size();i++)&#123; State s=vi[i]; if(s.local_monk==st.local_monk &amp;&amp; s.local_monster==st.local_monster &amp;&amp; s.remote_monk==st.remote_monk &amp;&amp; s.remote_monster==st.remote_monster &amp;&amp; s.i_boat==st.i_boat)&#123; n++; &#125; &#125; if(n&gt;=2)&#123; return true; &#125; return false;&#125;void search()&#123; State state=vi.back(); if(isEmpty(state) &amp;&amp; vi.size()&gt;1)&#123; return; &#125; if(isFinalState(state))&#123; return; &#125; for(int i=0;i&lt;10;i++)&#123; state=vi.back(); if(action[i][0]==boat)&#123; if((boat==0 &amp;&amp; state.local_monk&gt;=abs(action[i][1]) &amp;&amp; state.local_monster&gt;=abs(action[i][2])) || (boat==1 &amp;&amp; state.remote_monk&gt;=abs(action[i][1]) &amp;&amp; state.remote_monster&gt;=abs(action[i][2])))&#123; state.local_monk+=action[i][1]; state.local_monster+=action[i][2]; state.remote_monk-=action[i][1]; state.remote_monster-=action[i][2]; if(isEffective(state))&#123; boat=(++boat)%2; state.i_boat=boat; vi.push_back(state); c++; search(); vi.pop_back(); boat=(++boat)%2; c--; &#125; &#125; &#125; &#125;&#125;int main()&#123; State state; vi.push_back(state); search(); cout&lt;&lt;&quot;最少过河次数为：&quot;&lt;&lt;m&lt;&lt;endl;&#125; 在这道题中，过河这种动作共有5种动作，加上船在不同的两岸，所以需要乘2，一共10种情况。可利用深度优先进行遍历每一种状态生产状态树，不过由于深度优先可能会陷入状态回路中，所以需要从每次加入状态的集合里边判断是否有相同状态，对了，值得注意的是，船的状态也要判断，由于本人之前没判断船的状态，结果一直陷入调BUG中。","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"状态树","slug":"状态树","permalink":"http://yoursite.com/tags/状态树/"}]},{"title":"css3动画库animate.css的使用","date":"2017-04-23T14:40:20.000Z","path":"2017/04/23/css3动画库animate-css的使用/","text":"css3动画库animate.css的使用简介 animate.css 是一个来自国外的 CSS3 动画库，它预设了抖动（shake）、闪烁（flash）、弹跳（bounce）、翻转（flip）、旋转（rotateIn/rotateOut）、淡入淡出（fadeIn/fadeOut）等多达 60 多种动画效果，几乎包含了所有常见的动画效果。虽然借助 animate.css 能够很方便、快速的制作 CSS3 动画效果，但还是建议看看 animate.css 的代码，也许你能从中学到一些东西。 兼容 浏览器兼容：当然是只兼容支持 CSS3 animate 属性的浏览器，他们分别是：IE10+、Firefox、Chrome、Opera、Safari。 下载http://daneden.github.io/animate.css/ 使用方法1.引入文件及使用1&lt;link rel=&quot;stylesheet&quot; href=&quot;animate.min.css&quot;&gt; 1&lt;div class=&quot;animated bounce&quot; id=&quot;dowebok&quot;&gt;&lt;/div&gt; 搭配jquery 给元素加上 class 后，刷新页面，就能看到动画效果了。animated 类似于全局变量，它定义了动画的持续时间；bounce 是动画具体的动画效果的名称，你可以选择任意的效果。 如果动画是无限播放的，可以添加 class infinite。 你也可以通过 JavaScript 或 jQuery 给元素添加这些 class，比如：123$(function()&#123; $(&apos;#dowebok&apos;).addClass(&apos;animated bounce&apos;);&#125;); 有些动画效果最后会让元素不可见，比如淡出、向左滑动等等，可能你又需要将 class 删除，比如：（刚看到有些人直接复制了下边的代码没显示，原因是没添加触发事件，可以加一个hover/点击事件，把下面的代码复制进去，或者可以直接写123456$(function()&#123; $(&apos;#dowebok&apos;).addClass(&apos;animated bounce&apos;); setTimeout(function()&#123; $(&apos;#dowebok&apos;).removeClass(&apos;bounce&apos;); &#125;, 1000);&#125;); animate.css 的默认设置也许有些时候并不是我们想要的，所以你可以重新设置，比如： 12345#dowebok &#123; animate-duration: 2s; //动画持续时间 animate-delay: 1s; //动画延迟时间 animate-iteration-count: 2; //动画执行次数&#125;","tags":[{"name":"animate.css","slug":"animate-css","permalink":"http://yoursite.com/tags/animate-css/"},{"name":"css3动画","slug":"css3动画","permalink":"http://yoursite.com/tags/css3动画/"}]},{"title":"算法学习笔记-DP动态规划","date":"2017-04-23T13:12:39.000Z","path":"2017/04/23/算法学习笔记-DP动态规划/","text":"动态规划 动态规划相信大家都知道，动态规划算法也是新手在刚接触算法设计时很苦恼的问题，有时候觉得难以理解，但是真正理解之后，就会觉得动态规划其实并没有想象中那么难。网上也有很多关于讲解动态规划的文章，大多都是叙述概念，讲解原理，让人觉得晦涩难懂，即使一时间看懂了，发现当自己做题的时候又会觉得无所适从。我觉得，理解算法最重要的还是在于练习，只有通过自己练习，才可以更快地提升。话不多说，接下来，下面我就通过一个例子来一步一步讲解动态规划是怎样使用的，只有知道怎样使用，才能更好地理解，而不是一味地对概念和原理进行反复琢磨。 能用动规解决的问题的特点 问题具有最优子结构性质。如果问题的最优解所包含的 子问题的解也是最优的，我们就称该问题具有最优子结 构性质。 无后效性。当前的若干个状态值一旦确定，则此后过程的演变就只和这若干个状态的值有关，和之前是采取哪种手段或经过哪条路径演变到当前的这若干个状态，没有关系。 首先，我们来看一道题:数值三角形 7 3 88 1 02 7 4 44 5 2 6 5 在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99 输入格式： 5 //表示三角形的行数 接下来输入三角形 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 要求输出最大和 首先看到这道题，由于本人习惯了深度优先搜索的方式去处理问题，所以首先下意识的就想到深度优先搜索。 深度优先搜索代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int num[100][100],book[100][100];int direct[2][2]=&#123;&#123;1,0&#125;,&#123;1,1&#125;&#125;; //定义方向数组 int n;int m=0; //最大和 void func(int x,int y)&#123; if(x&gt;=n)&#123; int sum=0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(book[i][j]!=0)&#123; sum+=num[i][j]; &#125; &#125; &#125; if(sum&gt;m)&#123; m=sum; &#125; return; &#125; for(int i=0;i&lt;2;i++)&#123; if(book[x][y]==0)&#123; book[x][y]=1; func(x+direct[i][0],y+direct[i][1]); book[x][y]=0; &#125; &#125;&#125;int main()&#123; memset(num,0,sizeof(num)); memset(book,0,sizeof(book)); cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;i+1;j++)&#123; cin&gt;&gt;num[i][j]; &#125; &#125; func(0,0); cout&lt;&lt;m&lt;&lt;endl;&#125; 下面看动态规划代码: 动态规划代码1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int num[n][n]; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;i+1;j++)&#123; cin&gt;&gt;num[i][j]; &#125; &#125; for(int i=n-2;i&gt;=0;i--)&#123; for(int j=0;j&lt;i+1;j++)&#123; num[i][j]+=max(num[i+1][j],num[i+1][j+1]); &#125; &#125; cout&lt;&lt;num[0][0];&#125; 显而易见，动态规划这种方法的时间复杂度明显比深度优先高，所以在考虑此类问题时，为了追求更好的时间复杂度，可以选用动态规划。","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}]},{"title":"Axios(JS HTTP库/Ajax库)基本用法","date":"2017-04-22T12:48:28.000Z","path":"2017/04/22/Axios-JS-HTTP库-Ajax库-基本用法/","text":"Axios-JS特征vue更新到2.0之后，作者就不再对vue-resource更新了，而是推荐使用Axios。Axios的特征是： 在浏览器中发送 XMLHttpRequests 请求 比Jquery轻量，但处理请求不多时，可以使用 基于Promise语法标准 支持NodeJs 拦截请求和响应 自动转换JSON数据 客户端支持保护安全免受 XSRF 攻击 安装(没有安装npm的可以直接安装nodejs，自带npm) 安装到当前项目下：1npm install --save axios vue-axios 或全局安装：1npm install -g axios vue-axios 使用1234import Vue from &apos;vue&apos;import axios from &apos;axios&apos;import VueAxios from &apos;vue-axios&apos;Vue.use(VueAxios,axios) ##例子 发送get请求12345678910111213141516171819axios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); //上下代码等同axios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送post请求12345678910axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (response) &#123; console.log(response); &#125;); 发送多个并发请求12345678910 function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // Both requests are now complete &#125;)); 可以通过给axios传递参数来制定请求12345678axios(&#123; method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;); 在Vue中使用123456789Vue.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;)this.axios.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;)this.$http.get(api).then((response) =&gt; &#123; console.log(response.data)&#125;) 设置axios全局默认值您可以指定将应用于每个请求的配置默认值。 123axios.defaults.baseURL = &apos;https:/*api.example.com&apos;;axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; 拦截器你可以截取请求或响应在被 then 或者 catch 处理之前 12345678910111213141516171819/*添加请求拦截器*/axios.interceptors.request.use(function(config)&#123; /*在发送请求之前做某事*/ return config; &#125;，function(error)&#123; /*请求错误时做些事*/ return Promise.reject(error); &#125;);/*添加响应拦截器*/axios.interceptors.response.use(function(response)&#123; /*对响应数据做些事*/ return response; &#125;，function(error)&#123; /*请求错误时做些事*/ return Promise.reject(error); &#125;); /*如果你以后可能需要删除拦截器。*/var myInterceptor = axios.interceptors.request.use(function()&#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 取消请求您可以使用取消令牌取消请求。您可以使用CancelToken.source工厂创建一个取消令牌，如下所示：12345678910111213var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token&#125;).catch(function(thrown)&#123; if (axios.isCancel(thrown)) &#123; console.log(&apos;Request canceled&apos;, thrown.message); &#125; else &#123; /* 处理错误*/ &#125;&#125;);/*取消请求(消息参数是可选的)*/source.cancel(&apos;操作被用户取消。&apos;); 您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌： 12345678910var CancelToken = axios.CancelToken;var cancel;axios.get(&apos;/ user / 12345&apos;，&#123; cancelToken：new CancelToken(functionexecutor(c)&#123; /*一个执行器函数接收一个取消函数作为参数*/ cancel = c; &#125;)&#125;);/* 取消请求*/clear(); 注意：您可以使用相同的取消令牌取消几个请求。 axios在很大程度上受到Angular提供的$http服务的启发。 最终，axios努力提供一个在Angular外使用的独立的$http-like服务。","tags":[{"name":"axios","slug":"axios","permalink":"http://yoursite.com/tags/axios/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"入手GitHub+Hexo博客必备:MarkDown语法","date":"2017-04-19T14:06:06.000Z","path":"2017/04/19/入手GitHub-Hexo博客必备-MarkDown语法/","text":"标题设置（让字体变大，和word的标题意思一样）在Markdown当中设置标题，有两种方式：第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大） 块注释（blockquote）通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。） 斜体将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来 粗体将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来 无序列表在文字开头添加(, +, and -)实现无序列表。但是要注意在(, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式） 有序列表使用数字后面跟上句号。（还要有空格） 链接（Links）Markdown中有两种方式，实现链接，分别为内联方式和引用方式。 1234内联方式：This is an [example link](http://example.com/).引用方式：I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. [1]: http://google.com/ “Google” [2]: http://search.yahoo.com/ “Yahoo Search” [3]: http://search.msn.com/ “MSN Search” 图片（Images）图片的处理方式和链接的处理方式，非常的类似。 内联方式： 1![alt text](/path/to/img.jpg &quot;Title&quot;) 引用方式：12![alt text][id][id]: /path/to/img.jpg &quot;Title&quot; 代码（HTML中所谓的Code）实现方式有两种：第一种：简单文字出现一个代码框。使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~中的）第二种：大片文字需要实现代码框。使用Tab和四个空格。 脚注（footnote）实现方式如下：hello[^hello] 1[^hello]: hi 下划线在空白行下方添加三条“-”横线。（前面讲过在文字下方添加“-”，实现的2级标题）","tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://yoursite.com/tags/MarkDown/"}]},{"title":"hello hexo","date":"2017-04-18T14:20:06.000Z","path":"2017/04/18/hello-hexo/","text":"#Hello Hexo 很久以前就想搭建一个个人技术博客的网站了，但是那时候接触的东西不多，没有听说过hexo、jekyll、wordpress等快速blog生成工具，自己在网上找了博客模板，修改了一下前端代码，用eclipse基于jsp搭建了一个小型博客发布到阿里云，但是时间久了发现自己写的代码不稳定，经常获取不到数据库数据，于是放弃了做个人博客网站的想法。 后来听说了hexo，但是一直没有定下心去看官方文档，于是搭博客网站的想法再一次不了了之。今晚闲暇，实在不知道该干什么，于是捡起了搭博客的想法，入门了hexo搭建github博客，现在记录下来，也算是作个念象，给想要搭建个人博客网站的小伙伴们一个参考。","tags":[]},{"title":"Hello World","date":"2017-04-18T09:53:59.501Z","path":"2017/04/18/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]